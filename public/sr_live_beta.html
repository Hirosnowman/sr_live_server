<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SR 4カラムベータ — ポイント集計</title>
<style>
  :root{--bg:#f3f6fb;--card:#fff;--muted:#666;--accent:#0d6efd;}
  body{font-family: system-ui, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;margin:0;background:var(--bg);color:#111}
  header{position:fixed;top:0;left:0;right:0;background:#fff;border-bottom:1px solid #ddd;padding:8px;display:flex;align-items:center;gap:10px;z-index:120}
  header .left, header .center, header .right{display:flex;align-items:center;gap:8px}
  header input[type="text"]{padding:6px;border:1px solid #ccc;border-radius:6px}
  header button{padding:6px 10px;border-radius:6px;border:0;background:var(--accent);color:#fff;cursor:pointer}
  #toggleSettings{background:#444}
  #settingsPanel{display:none;position:absolute;right:10px;top:48px;background:#fff;border:1px solid #ccc;padding:10px;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.12);z-index:200;min-width:260px}
  #settingsPanel h4{margin:0 0 6px 0;font-size:13px}
  #settingsPanel label{display:inline-flex;align-items:center;gap:6px;margin-bottom:6px;font-size:13px}

  main{display:flex;gap:10px;padding:12px;margin-top:72px;height:calc(100vh - 84px)}
  .box{flex:1;background:var(--card);border:1px solid #ddd;border-radius:8px;padding:8px;overflow:auto;position:relative;min-width:180px;resize:both}
  .box h2{margin:0 0 8px 0;padding:6px;border-radius:6px;background:#f7f9fc;cursor:grab;user-select:none}
  .commentItem,.giftItem{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px;margin-bottom:6px}
  .commentItem img,.giftItem img{width:44px;height:44px;border-radius:6px;object-fit:cover}
  .giftItem{background:#fbfcfe;border:1px solid #f0f4fb}
  /* ポイントパネル */
  #pointsList{display:flex;flex-direction:column;gap:6px}
  .pointUser{background:#fff;border:1px solid #e6e6e6;border-radius:6px;padding:8px}
  .pointUserHeader{display:flex;justify-content:space-between;align-items:center;gap:8px;cursor:pointer}
  .pointUserHeader .title{font-weight:700}
  .pointUserBody{margin-top:8px;display:none;padding-top:6px;border-top:1px dashed #eee;font-size:13px}
  .small{font-size:13px;color:var(--muted)}
  /* responsive */
  @media (max-width:900px){ main{flex-direction:column;height:auto} .box{min-width:unset} #settingsPanel{right:8px;left:8px} }
</style>
</head>
<body>

<header>
  <div class="left">
    <label>Room ID: <input type="text" id="roomInput" placeholder="例: 490133"></label>
    <button id="switchRoomBtn">切替</button>
    <button id="toggleSettings">設定</button>
  </div>

  <div class="center">
    <span id="statusSpan" class="small">Status: 待機中</span>
    <span id="hbSpan" class="small">HB: 10s</span>
    <span id="kpSpan" class="small">KeyPoll: 5s</span>
    <span id="roomNameSpan" class="small">Room: -</span>
    <span id="startedSpan" class="small">開始: -</span>
    <span id="elapsedSpan" class="small">経過: -</span>
  </div>

  <div class="right" style="margin-left:auto;">
    <span class="small">（合計ポイントは降順）</span>
  </div>

  <!-- 設定パネル（右上、開閉） -->
  <div id="settingsPanel" aria-hidden="true">
    <h4>表示設定</h4>
    <div>
      <label>コメント 文字サイズ <input id="commentFontSize" type="number" min="10" max="36" value="14"> px</label>
      <label>色 <input id="commentColor" type="color" value="#000000"></label>
    </div>
    <div>
      <label>有料ギフト 文字サイズ <input id="paidFontSize" type="number" min="10" max="36" value="14"> px</label>
      <label>色 <input id="paidColor" type="color" value="#000000"></label>
    </div>
    <div>
      <label>無料ギフト 文字サイズ <input id="freeFontSize" type="number" min="10" max="36" value="14"> px</label>
      <label>色 <input id="freeColor" type="color" value="#000000"></label>
    </div>
    <div style="margin-top:8px;text-align:right">
      <button id="applyDisplaySettings">適用</button>
    </div>
  </div>
</header>

<main>
  <section class="box" id="commentsBox" style="flex:1.2">
    <h2 draggable="false">コメント</h2>
    <div id="commentList"></div>
  </section>

  <section class="box" id="paidBox" style="flex:1">
    <h2 draggable="false">有料ギフト（累積）</h2>
    <div id="paidList"></div>
  </section>

  <section class="box" id="freeBox" style="flex:1">
    <h2 draggable="false">無料ギフト（累積）</h2>
    <div id="freeList"></div>
  </section>

  <section class="box" id="pointsBox" style="flex:1.1">
    <h2 draggable="false">ギフトポイント累計（クリックで展開）</h2>
    <div id="pointsList" class="small"></div>
  </section>
</main>

<script>
/* ===========================================
   設定エリア / グローバルデータ構造
   =========================================== */
const ROOM_DEFAULT = 490133;

// ユーザー別集計データ構造
// users = { userId: { name, avatar, gifts: { giftId: {name, count, pointEach, lastTime, isPaid} }, totalPoints, paidPoints, freePoints, lastUpdate } }
const users = {};

// ギフトポイント参照テーブル（APIに point/price が無い場合に使用）
// 必要に応じてここにギフトIDとpointまたはpriceを追加してください。
// 例: 3000421: { name: "ハート(大)", price: 100 } , 3000001: { name: "無料星(黄)", point:1 }
const GIFT_POINT_TABLE = {
  // 例（実際のID・値は実環境に合わせて編集してください）
  3000421: { name: "ハート(大)", price: 100 },
  3000422: { name: "バラ", price: 500 },
  100001: { name: "星（黄）", point: 1 },
  100002: { name: "星（赤）", point: 2 },
  100003: { name: "星（青）", point: 5 },
  // ... 必要に応じて追加
};

// UI要素
const commentListEl = document.getElementById('commentList');
const paidListEl = document.getElementById('paidList');
const freeListEl = document.getElementById('freeList');
const pointsListEl = document.getElementById('pointsList');

let socket = null;
let broadcastKey = null;
let currentRoom = ROOM_DEFAULT;
let startedAtSec = null;
let mainRoomName = "-";

// heartbeat / keyPoll / reconnect
const HB_INTERVAL = 10000; // ms
const KEY_POLL_INTERVAL = 5000; // ms
let reconnectDelay = 1000;
const MAX_RECONNECT = 60000;

/* ===========================================
   ヘルパー: ギフトポイント取得
   - giftObj: 受信したギフトオブジェクト（g:giftId, n:num, price? point?）
   - 戻り値: { pointEach, name, isPaid(boolean) }
   =========================================== */
function resolveGiftMeta(giftObj) {
  const id = String(giftObj.g);
  // 1) 受信オブジェクトに price/pointがあればそれを使う
  if (giftObj.price !== undefined && Number(giftObj.price) > 0) {
    return { pointEach: Number(giftObj.price), name: giftObj.g_name || `gift_${id}`, isPaid: true };
  }
  if (giftObj.point !== undefined && Number(giftObj.point) >= 0) {
    return { pointEach: Number(giftObj.point), name: giftObj.g_name || `gift_${id}`, isPaid: (giftObj.gt !== undefined ? Number(giftObj.gt)===1 : false) };
  }
  // 2) テーブル参照
  if (GIFT_POINT_TABLE[id]) {
    const info = GIFT_POINT_TABLE[id];
    if (info.price !== undefined) return { pointEach: Number(info.price), name: info.name || `gift_${id}`, isPaid: true };
    if (info.point !== undefined) return { pointEach: Number(info.point), name: info.name || `gift_${id}`, isPaid: !(info.point===0) };
  }
  // 3) フォールバック：無料扱いで1pt（保険）
  return { pointEach: 1, name: giftObj.g_name || `gift_${id}`, isPaid: (giftObj.gt!==undefined ? Number(giftObj.gt)===1 : false) };
}

/* ===========================================
   UI 更新関数
   - コメントは prepend（最新上）
   - ギフト一覧（有料/無料）は個別ボックスで累積
   - ポイント一覧は users を基に作り直して合計降順ソートで表示
   =========================================== */

function renderComment(obj){
  const div = document.createElement('div');
  div.className = 'commentItem';
  const ava = document.createElement('img'); ava.src = `https://image.showroom-cdn.com/showroom-prod/image/avatar/${obj.av}.png`;
  const p = document.createElement('div'); p.textContent = `${obj.ac}: ${obj.cm}`;
  p.style.fontSize = getSettingFont('comment') + 'px';
  p.style.color = getSettingColor('comment');
  div.appendChild(ava); div.appendChild(p);
  commentListEl.prepend(div);
  // limit
  if(commentListEl.children.length > 300) commentListEl.removeChild(commentListEl.lastChild);
}

function renderGiftListForId(containerEl, userId, giftId){
  // containerElは paidListEl or freeListEl
  const key = `${userId}_${giftId}`;
  const data = users[userId].gifts[giftId];
  let div = containerEl.querySelector(`#${key}`);
  if(!div){
    div = document.createElement('div');
    div.id = key;
    div.className = 'giftItem';
    containerEl.prepend(div);
  } else {
    // move to top (latest)
    containerEl.prepend(div);
  }
  div.innerHTML = '';
  const ava = document.createElement('img');
  ava.src = `https://image.showroom-cdn.com/showroom-prod/image/avatar/${users[userId].avatar}.png`;
  const giftImg = document.createElement('img');
  // ギフト画像URL（存在しなければ空アイコン）
  giftImg.src = `https://static.showroom-live.com/image/gift/${giftId}_s.png?v=7`;
  giftImg.width = 36;
  const info = document.createElement('div');
  info.innerHTML = `<div style="font-weight:700">${users[userId].name}</div>
                    <div>${data.name} × ${data.count} → ${data.points} pt</div>
                    <div class="small">更新: ${new Date(data.lastTime).toLocaleTimeString()}</div>`;
  // スタイル
  info.style.fontSize = (containerEl===paidListEl ? getSettingFont('paid') : getSettingFont('free')) + 'px';
  info.style.color = (containerEl===paidListEl ? getSettingColor('paid') : getSettingColor('free'));
  div.appendChild(ava); div.appendChild(giftImg); div.appendChild(info);
}

function renderAllGiftPanels(){
  // clear lists
  paidListEl.innerHTML = '';
  freeListEl.innerHTML = '';
  // iterate users and their gifts — but we will not sort here; order in points panel handles ranking
  for(const uid in users){
    const user = users[uid];
    for(const gid in user.gifts){
      const g = user.gifts[gid];
      const container = g.isPaid ? paidListEl : freeListEl;
      renderGiftListForId(container, uid, gid);
    }
  }
}

function renderPointsPanel(){
  // build array of users with totals
  const arr = Object.keys(users).map(uid => {
    const u = users[uid];
    return { uid, name: u.name, avatar: u.avatar, total: u.totalPoints, paid: u.paidPoints, free: u.freePoints, lastUpdate: u.lastUpdate, gifts: u.gifts };
  });
  // sort by total desc
  arr.sort((a,b) => b.total - a.total);
  // render
  pointsListEl.innerHTML = '';
  arr.forEach(u => {
    const wrapper = document.createElement('div');
    wrapper.className = 'pointUser';
    // header (click to toggle body)
    const hdr = document.createElement('div');
    hdr.className = 'pointUserHeader';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = `${u.name}（合計 ${u.total} pt）`;
    const meta = document.createElement('div');
    meta.className = 'small';
    meta.textContent = `有料:${u.paid}pt 無料:${u.free}pt`;
    hdr.appendChild(title); hdr.appendChild(meta);
    // body (details per gift)
    const body = document.createElement('div');
    body.className = 'pointUserBody';
    // gift rows
    const list = document.createElement('div');
    for(const gid in u.gifts){
      const g = u.gifts[gid];
      const row = document.createElement('div');
      row.textContent = `・${g.name} (ID:${gid}) × ${g.count} → ${g.points} pt`;
      list.appendChild(row);
    }
    const footer = document.createElement('div');
    footer.style.marginTop='6px';
    footer.className='small';
    footer.textContent = `最終更新: ${new Date(u.lastUpdate).toLocaleTimeString()}`;
    body.appendChild(list); body.appendChild(footer);

    // toggle
    hdr.addEventListener('click', ()=> {
      if(body.style.display === 'block') body.style.display = 'none';
      else body.style.display = 'block';
    });

    wrapper.appendChild(hdr); wrapper.appendChild(body);
    pointsListEl.appendChild(wrapper);
  });
}

/* ===========================================
   ギフト受信処理（累積ロジック）
   - obj: 受信オブジェクト（obj.g, obj.u, obj.ac, obj.av, obj.n, obj.gt, obj.created_at, ...）
   =========================================== */
function handleGift(obj){
  try{
    const uid = String(obj.u || obj.user_id || obj.uid || obj.ac || 'unknown');
    const gid = String(obj.g);
    const num = Number(obj.n || 1);
    const ac = obj.ac || 'unknown';
    const av = obj.av || 0;
    const gt = Number(obj.gt || 1); // 1:有料(従来), 2:無料

    // ensure user exists
    if(!users[uid]) users[uid] = { name: ac, avatar: av, gifts: {}, totalPoints:0, paidPoints:0, freePoints:0, lastUpdate: Date.now() };

    // resolve gift meta
    const meta = resolveGiftMeta(obj); // {pointEach, name, isPaid}
    const pointEach = Number(meta.pointEach || 0);
    const name = meta.name;
    const isPaid = !!meta.isPaid;

    // update gift entry
    if(!users[uid].gifts[gid]) users[uid].gifts[gid] = { name, count: 0, points: 0, pointEach, isPaid, lastTime: Date.now() };
    const entry = users[uid].gifts[gid];
    entry.count += num;
    entry.points += pointEach * num;
    entry.pointEach = pointEach;
    entry.isPaid = isPaid;
    entry.lastTime = Date.now();

    // update per-user totals
    users[uid].totalPoints = (users[uid].totalPoints || 0) + pointEach * num;
    if(isPaid) users[uid].paidPoints = (users[uid].paidPoints || 0) + pointEach * num;
    else users[uid].freePoints = (users[uid].freePoints || 0) + pointEach * num;
    users[uid].lastUpdate = Date.now();

    // update name/avatar to latest
    users[uid].name = ac;
    users[uid].avatar = av;

    // re-render relevant parts
    // update gift list for this gift
    renderGiftListForId(isPaid ? paidListEl : freeListEl, uid, gid);
    // update points panel (full re-render sorted)
    renderPointsPanel();
  }catch(e){ console.error('handleGift error', e); }
}

/* ===========================================
   WebSocket / Live info / reconnect logic
   - try local proxy endpoints first: /get_broadcast_key and /get_live_info
   - fallback: direct showroom api (may be blocked by CORS)
   =========================================== */

async function fetchBroadcastKeyProxy(roomId){
  // proxy endpoint you probably already have on your server
  try{
    const r = await fetch(`/get_broadcast_key?room_id=${roomId}`);
    if(!r.ok) return null;
    const j = await r.json();
    return j.broadcast_key || j.bcsvr_key || null;
  }catch(e){ return null; }
}

async function fetchLiveInfoProxy(roomId){
  try{
    const r = await fetch(`/get_live_info?room_id=${roomId}`);
    if(!r.ok) return null;
    const j = await r.json();
    return j;
  }catch(e){ return null; }
}

// fallback to direct endpoints (may fail due to CORS)
async function fetchBroadcastKeyDirect(roomId){
  try{
    const r = await fetch(`https://www.showroom-live.com/api/live/room_status?room_id=${roomId}`);
    if(!r.ok) return null;
    const j = await r.json();
    return j.data?.bcsvr_key || j.bcsvr_key || null;
  }catch(e){ return null; }
}
async function fetchLiveInfoDirect(roomId){
  try{
    const r = await fetch(`https://www.showroom-live.com/api/live/live_info?room_id=${roomId}`);
    if(!r.ok) return null;
    const j = await r.json();
    return j.data || j;
  }catch(e){ return null; }
}

async function getBroadcastKey(roomId){
  let key = await fetchBroadcastKeyProxy(roomId);
  if(key) return key;
  key = await fetchBroadcastKeyDirect(roomId);
  return key;
}
async function getLiveInfo(roomId){
  let info = await fetchLiveInfoProxy(roomId);
  if(info) return info;
  info = await fetchLiveInfoDirect(roomId);
  return info;
}

// connect and subscribe
async function connectRoom(roomId){
  try{
    document.getElementById('statusSpan').textContent = 'Status: ルーム情報取得中...';
    const info = await getLiveInfo(roomId);
    if(info){
      mainRoomName = info.room_name || info.main_name || mainRoomName;
      if(info.started_at) startedAtSec = Number(info.started_at);
      document.getElementById('roomNameSpan').textContent = 'Room: ' + mainRoomName;
      document.getElementById('startedSpan').textContent = startedAtSec ? '開始: ' + new Date((startedAtSec*1000)).toLocaleString() : '開始: -';
    } else {
      // keep previous
    }

    const key = await getBroadcastKey(roomId);
    if(!key){
      document.getElementById('statusSpan').textContent = 'Status: broadcast_key 取得失敗';
      scheduleReconnect();
      return;
    }
    broadcastKey = key;

    // close old socket
    if(socket){ try{ socket.close(); }catch(e){} }

    socket = new WebSocket('wss://online.showroom-live.com');
    socket.addEventListener('open', ()=> {
      socket.send('SUB\t' + broadcastKey);
      document.getElementById('statusSpan').textContent = 'Status: 接続中';
      reconnectDelay = 1000;
    });
    socket.addEventListener('message', e=> {
      const data = e.data;
      if(typeof data !== 'string') return;
      if(data.startsWith('ACK') || data.startsWith('ERR')) return;
      // remove prefix
      const jsonText = data.replace(`MSG\t${broadcastKey}`, '');
      let obj;
      try{ obj = JSON.parse(jsonText); }catch(err){ return; }
      // comment
      if(obj.cm) renderComment(obj);
      // gift
      if(obj.g) handleGift(obj);
      // some servers may include main_name/started_at in other messages
      if(obj.main_name && obj.main_name !== mainRoomName){
        mainRoomName = obj.main_name;
        document.getElementById('roomNameSpan').textContent = 'Room: ' + mainRoomName;
      }
      if(obj.started_at && !startedAtSec){
        startedAtSec = Number(obj.started_at);
        document.getElementById('startedSpan').textContent = '開始: ' + new Date(startedAtSec*1000).toLocaleString();
      }
    });
    socket.addEventListener('close', ()=> {
      document.getElementById('statusSpan').textContent = 'Status: 切断';
      scheduleReconnect();
    });
    socket.addEventListener('error', ()=> {
      document.getElementById('statusSpan').textContent = 'Status: エラー';
      scheduleReconnect();
    });

    // clear lists when new room connected
    commentListEl.innerHTML = '';
    paidListEl.innerHTML = '';
    freeListEl.innerHTML = '';
    pointsListEl.innerHTML = '';
    // clear users
    for(const k in users) delete users[k];

  }catch(err){
    console.error(err);
    document.getElementById('statusSpan').textContent = 'Status: エラー';
    scheduleReconnect();
  }
}

function scheduleReconnect(){
  setTimeout(()=>connectRoom(currentRoom), reconnectDelay);
  reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT);
}

/* ===========================================
   Heartbeat / KeyPoll
   =========================================== */
setInterval(()=>{
  if(socket && socket.readyState === 1){
    try{ socket.send('PING'); }catch(e){}
  }
}, HB_INTERVAL);

setInterval(async ()=>{
  // check broadcast_key still valid; if changed, reconnect
  try{
    const key = await getBroadcastKey(currentRoom);
    if(key && key !== broadcastKey){
      // key changed -> reconnect to new one
      connectRoom(currentRoom);
    }
  }catch(e){}
}, KEY_POLL_INTERVAL);

/* ===========================================
   Settings UI
   =========================================== */
function getSettingFont(target){
  if(target==='comment') return Number(document.getElementById('commentFontSize').value) || 14;
  if(target==='paid') return Number(document.getElementById('paidFontSize').value) || 14;
  return Number(document.getElementById('freeFontSize').value) || 14;
}
function getSettingColor(target){
  if(target==='comment') return document.getElementById('commentColor').value || '#000';
  if(target==='paid') return document.getElementById('paidColor').value || '#000';
  return document.getElementById('freeColor').value || '#000';
}

document.getElementById('applyDisplaySettings').addEventListener('click', ()=>{
  // apply to existing items quickly
  document.querySelectorAll('#commentList > *').forEach(el=>{
    el.style.fontSize = getSettingFont('comment') + 'px';
    el.style.color = getSettingColor('comment');
  });
  document.querySelectorAll('#paidList .giftItem').forEach(el=>{
    el.style.fontSize = getSettingFont('paid') + 'px';
    el.style.color = getSettingColor('paid');
  });
  document.querySelectorAll('#freeList .giftItem').forEach(el=>{
    el.style.fontSize = getSettingFont('free') + 'px';
    el.style.color = getSettingColor('free');
  });
  // also update points panel font sizes if needed (optional)
});

/* toggle settings panel */
document.getElementById('toggleSettings').addEventListener('click', ()=>{
  const panel = document.getElementById('settingsPanel');
  panel.style.display = (panel.style.display === 'block') ? 'none' : 'block';
  panel.setAttribute('aria-hidden', panel.style.display === 'none');
});

/* ===========================================
   Drag: box を上の h2 を掴んで移動できる（簡易）
   =========================================== */
function makeDraggableBox(boxEl){
  const handle = boxEl.querySelector('h2');
  let isDown=false, startX=0, startY=0, origX=0, origY=0;
  handle.addEventListener('mousedown', (e)=>{
    isDown = true;
    startX = e.clientX; startY = e.clientY;
    const rect = boxEl.getBoundingClientRect();
    origX = rect.left; origY = rect.top;
    boxEl.style.zIndex = 1000;
    document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', (e)=>{
    if(!isDown) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    boxEl.style.position = 'absolute';
    boxEl.style.left = (origX + dx) + 'px';
    boxEl.style.top = (origY + dy) + 'px';
  });
  document.addEventListener('mouseup', ()=>{ isDown = false; boxEl.style.zIndex = ''; document.body.style.userSelect = ''; });
}
// apply to boxes
['commentsBox','paidBox','freeBox','pointsBox'].forEach(id=>{
  const el = document.getElementById(id);
  if(el) makeDraggableBox(el);
});

/* ===========================================
   初期 / イベントバインド
   =========================================== */
document.getElementById('switchRoomBtn').addEventListener('click', ()=>{
  const val = document.getElementById('roomInput').value.trim();
  if(!val) return;
  currentRoom = val;
  reconnectDelay = 1000;
  connectRoom(currentRoom);
});

// initial connect
connectRoom(currentRoom);
</script>

</body>
</html>
